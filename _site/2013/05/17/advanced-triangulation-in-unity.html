<!DOCTYPE html>
<html>
	<head>
		<title>  Advanced Triangulation in Unity | ToTheMathmos.com</title>
		<link rel="icon" type="/image/ico" href="images/favicon.ico">
        <link rel="stylesheet" type="text/css" href="/css/style2.css" />
		<link rel="stylesheet" type="text/css" href="/css/csharp.css" >
		<link rel="stylesheet" type="text/css" href="/css/syntax.css" >
			<script type="text/javascript" src="/js/banner.js"></script>
			<script type="application/javascript">
				//initBanner();
			</script>
	</head>
	<body>
		<div id="everything">
			<div id="header">
				<!--<canvas id="bannerbg" width="1000" height="150">-->
					<img src="/images/banner-backup.png" alt="banner"/>
				<!--</canvas>-->
		   </div>
			<div id="middle">
                <div id="left_column">
                    <div id="navigation">
						<a href="/">Blog</a>
						<a href="/portfolio/">Portfolio</a>
						<a href="/cv/">CV</a>
						<a href="/about/">About</a>
					</div>
				</div>
				<div id="middle_column">
					<div id="page_title">Advanced Triangulation in Unity</div>
					<div id="content">
						<div class="blog_post">
	<h1>Advanced Triangulation in Unity</h1>
	<div class="blog_post_body">
		<p style="font-weight:bold;">2013-05-17</p>
		<p>The purpose of these script are for generating triangles for advanced 2D polygons. If you are just attempting to triangulating individual concave or convex polygons I recommend using this instead <a href='http://wiki.unity3d.com/index.php?title=Triangulator'>Triangulator</a>, but if you need to triangulate something more advanced like polygons with holes or multiple polygons at once you probably need to use the following. </p><div class='imagebox'>
    <img src='/images/blog/Polygon1.png' width='350px' />
    <div class='caption'>
    A PSLG containing multiple polygons and a hole.
    </div>
</div><div class='imagebox'>
    <img src='/images/blog/Polygon3.png' width='350px' />
    <div class='caption'>
    The triangulated result.
    </div>
</div><!--<div style="clear:both"></div>--><!-- more --><p>The way works is that you produce the polygon outline in the form of a planar straight line graph (a PSLG) using the PSLG class. This is passed to a program called <a href='http://www.cs.cmu.edu/~quake/triangle.html'>Triangle</a>, which performs the actual triangulation. Download a compiled version for Windows <a href='/files/triangle.exe'>here</a> and place it in the directory C:\Triangle\ .</p><h2>Usage</h2><div>
    <pre><code class='c#'>using UnityEngine;
using System.Collections;
using System.Collections.Generic;

public class TestTriangleAPI : MonoBehaviour {

    // Use this for initialization
    void Start () {
        if (gameObject.activeSelf)
        {
            List&lt;Vector2&gt; testVertices1 = new List&lt;Vector2&gt;(6);
            testVertices1.Add(new Vector2(1f, 0f));
            testVertices1.Add(new Vector2(0f, 6f));
            testVertices1.Add(new Vector2(3f, 5f));
            testVertices1.Add(new Vector2(4f, 7f));
            testVertices1.Add(new Vector2(6f, 6f));
            testVertices1.Add(new Vector2(6.5f, 2f));

            List&lt;Vector2&gt; testVertices2 = new List&lt;Vector2&gt;(3);
            testVertices2.Add(new Vector2(1.5f, 6.5f));
            testVertices2.Add(new Vector2(2.25f, 8f));
            testVertices2.Add(new Vector2(3.25f, 6.25f));

            List&lt;Vector2&gt; hole1 = new List&lt;Vector2&gt;(5);
            hole1.Add(new Vector2(3.5f, 3));
            hole1.Add(new Vector2(4.5f, 2.5f));
            hole1.Add(new Vector2(5.5f, 3.5f));
            hole1.Add(new Vector2(5f, 4f));
            hole1.Add(new Vector2(4f, 4f));

            PSLG testPSLG = new PSLG();
            testPSLG.AddVertexLoop(testVertices1);
            testPSLG.AddVertexLoop(testVertices2);
            testPSLG.AddHole(hole1);

            TriangleAPI triangle = new TriangleAPI();
            Polygon2D polygon = triangle.Triangulate(testPSLG);
            string tris = polygon.triangles.Length / 3 + &quot;: &quot;;
            foreach (int i in polygon.triangles)
            {
                tris += i + &quot;, &quot;;
            }
            
            string verts = polygon.vertices.Length + &quot;: &quot;;
            foreach (Vector2 i in polygon.vertices)
            {
                verts += i + &quot;, &quot;;
            }

            MeshBuilder builder = new MeshBuilder();

            for (int i = 0; i &lt; polygon.triangles.Length; i += 3)
            {
                int[] indices = new int[] { polygon.triangles[i], polygon.triangles[i + 1], polygon.triangles[i + 2] };
                Vector3[] tri = new Vector3[] { polygon.vertices[indices[0]], polygon.vertices[indices[1]], polygon.vertices[indices[2]] };
                Vector3 normal = new Plane(tri[0], tri[1], tri[2]).normal;
                Vector3[] normals = new Vector3[] { normal, normal, normal };
                Vector2[] uvs = new Vector2[] { tri[0], tri[1], tri[2] };
                builder.AddTriangleToMesh(tri, normals, uvs);
            }

            Mesh mesh = builder.Build();

            gameObject.AddComponent&lt;MeshFilter&gt;().mesh = mesh;
            gameObject.AddComponent&lt;MeshRenderer&gt;().material = new Material(Shader.Find(&quot;Diffuse&quot;));
        }
    }
}</code></pre>
  </div>
<p>Get the MeshBuilder class here <a href='/files/MeshBuilder.cs'>MeshBuilder.cs</a>.</p>
<h2>TriangleAPI.cs</h2><div>
    <pre><code class='c#'>using UnityEngine;
using System.Collections;
using System.IO;
using System.Collections.Generic;
using System;

public class TriangleAPI {

    // Use this for initialization
    public Polygon2D Triangulate(PSLG pslg)  {
        if (pslg.vertices.Count == 0)
        {
            Debug.LogError(&quot;No vertices passed to triangle. hole count: &quot; + pslg.holes.Count + &quot;, vert count: &quot; + pslg.vertices.Count);
            return new Polygon2D(new int[] { }, new Vector2[] { });
        }
        else 
        {
            // Write poly file
            WritePolyFile(pslg);
        
            // Execute Triangle
            ExecuteTriangle();
        
            // Read outout
            Vector2[] vertices = ReadVerticesFile();
            int[] triangles = ReadTrianglesFile();
        
            CleanUp();

            return new Polygon2D(triangles, vertices);
        }
    }

    void WritePolyFile(PSLG pslg)
    {
        
            
        try
        {
            string polyFilePath = &quot;C:\\triangle\\polygon.poly&quot;;
            if (File.Exists(polyFilePath))
            {
                File.Delete(polyFilePath);
            }

            using (StreamWriter sw = File.CreateText(polyFilePath))
            {
                sw.WriteLine(&quot;# polygon.poly&quot;);
                sw.WriteLine(&quot;# generated by Unity Triangle API&quot;);
                sw.WriteLine(&quot;#&quot;);
                // Vertices
                sw.WriteLine(pslg.GetNumberOfSegments() + &quot; 2 0 1&quot;);
                sw.WriteLine(&quot;# The polyhedrons.&quot;);
                int boundaryMarker = 2;
                int i;
                for (i = 0; i &lt; pslg.vertices.Count; i++)
                {
                    if (i != 0 &amp;&amp; pslg.boundaryMarkersForPolygons.Contains(i))
                    {
                        boundaryMarker++;
                    }
                    sw.WriteLine(i + 1 + &quot;\t&quot; + pslg.vertices[i].x + &quot;\t&quot; + pslg.vertices[i].y + &quot;\t&quot; + boundaryMarker);
                }
                int offset = i;
                for (i = 0; i &lt; pslg.holes.Count; i++)
                {
                    sw.WriteLine(&quot;# Hole #&quot; + (i + 1));
                    int j;
                    for (j = 0; j &lt; pslg.holes[i].vertices.Count; j++)
                    {
                        sw.WriteLine((offset + j + 1) + &quot;\t&quot; + pslg.holes[i].vertices[j].x + &quot;\t&quot; + pslg.holes[i].vertices[j].y + &quot;\t&quot; + (boundaryMarker + i + 1));
                    }
                    offset += j;
                }

                // Line segments
                sw.WriteLine();
                sw.WriteLine(&quot;# Line segments.&quot;);
                sw.WriteLine(pslg.GetNumberOfSegments() + &quot; 1&quot;);
                sw.WriteLine(&quot;# The polyhedrons.&quot;);
                boundaryMarker = 2;
                for (i = 0; i &lt; pslg.segments.Count; i++)
                {
                    if (i != 0 &amp;&amp; pslg.boundaryMarkersForPolygons.Contains(i))
                    {
                        boundaryMarker++;
                    }
                    sw.WriteLine(i + 1 + &quot;\t&quot; + (pslg.segments[i][0] + 1) + &quot;\t&quot; + (pslg.segments[i][1] + 1) + &quot;\t&quot; + boundaryMarker);
                }
                offset = i;
                for (i = 0; i &lt; pslg.holes.Count; i++)
                {
                    sw.WriteLine(&quot;# Hole #&quot; + (i + 1));
                    int j;
                    for (j = 0; j &lt; pslg.holes[i].segments.Count; j++)
                    {
                        sw.WriteLine((offset + j + 1) + &quot;\t&quot; + (offset + 1 + pslg.holes[i].segments[j][0]) + &quot;\t&quot; + (offset + 1 + pslg.holes[i].segments[j][1]) + &quot;  &quot; + (boundaryMarker + i + 1));
                    }
                    offset += j;
                }

                // Holes
                sw.WriteLine();
                sw.WriteLine(&quot;# Holes.&quot;);
                sw.WriteLine(pslg.holes.Count);
                for (i = 0; i &lt; pslg.holes.Count; i++)
                {
                    Vector2 point = pslg.GetPointInHole(pslg.holes[i]);
                    sw.WriteLine((i + 1) + &quot;\t&quot; + point.x + &quot;\t&quot; + point.y + &quot;\t # Hole #&quot; + (i + 1));
                }
                sw.Close();
            }
        }
        catch (Exception e)
        {
            Debug.LogException(e);
        }
    }

    void ExecuteTriangle()
    {
        try
        {
            System.Diagnostics.Process process = new System.Diagnostics.Process();
            process.StartInfo.FileName = &quot;C:\\triangle\\triangle.exe&quot;;
            process.StartInfo.Arguments = &quot;-pPq0 C:\\triangle\\polygon.poly&quot;;
            process.StartInfo.RedirectStandardOutput = true;
            process.StartInfo.UseShellExecute = false;
            process.StartInfo.CreateNoWindow = true;
            process.Start();
            
            //string output = process.StandardOutput.ReadToEnd();
            //Debug.Log(output);
            
            process.WaitForExit();
        }
        catch (System.Exception e)
        {
            Debug.LogException(e);
        }
    }

    Vector2[] ReadVerticesFile()
    {
        Vector2[] vertices = null;
        try
        {
            string outputVerticesFile = &quot;C:\\triangle\\polygon.1.node&quot;;

            StreamReader sr = File.OpenText(outputVerticesFile);

            string line = sr.ReadLine();
            int n = line.IndexOf(&quot;  &quot;);
            int nVerts = int.Parse(line.Substring(0, n));
            vertices = new Vector2[nVerts];

            int whileCount = 0;

            while ((line = sr.ReadLine()) != null)
            {
                int index = -1;
                float x = 0f;
                float y = 0f;
                int c = 0;
                if (!line.Contains(&quot;#&quot;))
                {
                    string[] stringBits = line.Split(&#39; &#39;);

                    foreach (string s in stringBits)
                    {
                        if (s != &quot;&quot; &amp;&amp; s != &quot; &quot;)
                        {
                            if (c == 0)
                                index = int.Parse(s);
                            else if (c == 1)
                                x = float.Parse(s);
                            else if (c == 2)
                                y = float.Parse(s);

                            c++;
                        }
                    }
                }

                if (index != -1)
                {
                    vertices[index - 1] = new Vector2(x, y);
                }


                whileCount++;
                if (whileCount &gt; 1000)
                {
                    Debug.LogError(&quot;Stuck in while loop&quot;);
                    break;
                }
            }

            sr.Close();
        }
        catch (Exception e)
        {
            Debug.LogException(e);
        }

        return vertices;
    }

    private int[] ReadTrianglesFile()
    {
        List&lt;int&gt; triList = null;
        try
        {
            string outputTrianglesFile = &quot;C:\\triangle\\polygon.1.ele&quot;;

            using (StreamReader sr = File.OpenText(outputTrianglesFile))
            {

                string line = sr.ReadLine();
                int n = line.IndexOf(&quot;  &quot;);
                int nTriangles = int.Parse(line.Substring(0, n));
                //int[] triangles = new int[nTriangles * 3];
                triList = new List&lt;int&gt;(nTriangles * 3);

                int count = 0;

                while ((line = sr.ReadLine()) != null)
                {
                    int index = -1;
                    int c = 0;
                    int[] tri = new int[3];
                    if (!line.Contains(&quot;#&quot;))
                    {
                        string[] stringBits = line.Split(&#39; &#39;);

                        foreach (string s in stringBits)
                        {
                            if (s != &quot;&quot; &amp;&amp; s != &quot; &quot;)
                            {
                                if (c == 0)
                                    index = int.Parse(s);
                                else if (c == 1)
                                    tri[0] = int.Parse(s) - 1;
                                else if (c == 2)
                                    tri[1] = int.Parse(s) - 1;
                                else if (c == 3)
                                    tri[2] = int.Parse(s) - 1;

                                c++;
                            }
                        }
                    }

                    if (index != -1)
                    {
                        triList.AddRange(tri);
                    }

                    count++;
                    if (count &gt; 1000)
                    {
                        Debug.LogError(&quot;Stuck in while loop&quot;);
                        break;
                    }
                }

                sr.Close();
            }
        }
        catch (Exception e)
        {
            Debug.LogException(e);
        }

        return triList.ToArray();
    }

    private void CleanUp()
    {
        try
        {
            File.Delete(&quot;C:\\triangle\\polygon.1.ele&quot;);
            File.Delete(&quot;C:\\triangle\\polygon.1.node&quot;);
            File.Delete(&quot;C:\\triangle\\polygon.poly&quot;);
        }
        catch (Exception e)
        {
            Debug.LogException(e);
        }
    }
}</code></pre>
  </div><h2>PSLG.cs</h2><div>
    <pre><code class='c#'>using UnityEngine;
using System.Collections;
using System.Collections.Generic;

public class PSLG {
    public List&lt;Vector2&gt; vertices;
    public List&lt;int[]&gt; segments;
    public List&lt;PSLG&gt; holes;
    public List&lt;int&gt; boundaryMarkersForPolygons;
    
    public PSLG()
    {
        vertices = new List&lt;Vector2&gt;();
        segments = new List&lt;int[]&gt;();
        holes = new List&lt;PSLG&gt;();
        boundaryMarkersForPolygons = new List&lt;int&gt;();
    }

    public PSLG(List&lt;Vector2&gt; vertices) : this()
    {
        this.AddVertexLoop(vertices);
    }
    
    public void AddVertexLoop(List&lt;Vector2&gt; vertices)
    {
        if (vertices.Count &lt; 3)
        {
            Debug.Log(&quot;A vertex loop cannot have less than three vertices &quot; + vertices.Count);
        }
        else
        {
            this.vertices.AddRange(vertices);
            int segmentOffset = segments.Count;
            boundaryMarkersForPolygons.Add(segments.Count);
            for(int i = 0; i &lt; vertices.Count - 1; i++)
            {
                segments.Add(new int[] { i + segmentOffset, i + 1 + segmentOffset });
            }
            segments.Add(new int[] { vertices.Count - 1 + segmentOffset, segmentOffset });
        }
    }

    public void AddOrderedVertices(Vector2[] vertices)
    {
        AddVertexLoop(new List&lt;Vector2&gt;(vertices));
    }

    public void AddHole(List&lt;Vector2&gt; vertices)
    {
        PSLG hole = new PSLG();
        hole.AddVertexLoop(vertices);
        holes.Add(hole);
    }

    public void AddHole(Vector2[] vertices)
    {
        AddHole(new List&lt;Vector2&gt;(vertices));
    }

    public int GetNumberOfSegments()
    {
        int offset = vertices.Count;
        foreach (PSLG hole in holes)
        {
            offset += hole.segments.Count;
        }

        return offset;
    }

    public bool IsPointInPolygon(Vector2 point)
    {
        int j = segments.Count - 1;
        bool oddNodes = false;

        for (int i = 0; i &lt; segments.Count; i++)
        {
            if ((vertices[i].y &lt; point.y &amp;&amp; vertices[j].y &gt;= point.y
            || vertices[j].y &lt; point.y &amp;&amp; vertices[i].y &gt;= point.y)
            &amp;&amp; (vertices[i].x &lt;= point.x || vertices[j].x &lt;= point.x))
            {
                oddNodes ^= (vertices[i].x + (point.y - vertices[i].y) / (vertices[j].y - vertices[i].y) * (vertices[j].x - vertices[i].x) &lt; point.x);
            }
            j = i;
        }

        return oddNodes;
    }

    public Vector2 GetPointInPolygon()
    {
        float topMost = vertices[0].y;
        float bottomMost = vertices[0].y;
        float leftMost = vertices[0].x;
        float rightMost = vertices[0].x;

        foreach (Vector2 vertex in vertices)
        {
            if (vertex.y &gt; topMost)
                topMost = vertex.y;
            if (vertex.y &lt; bottomMost)
                bottomMost = vertex.y;
            if (vertex.x &lt; leftMost)
                leftMost = vertex.x;
            if (vertex.x &gt; rightMost)
                leftMost = vertex.x;
        }
        
        Vector2 point;
        
        int whileCount = 0;
        do
        {
            point = new Vector2(Random.Range(leftMost, rightMost), Random.Range(bottomMost, topMost));
            whileCount++;
            if (whileCount &gt; 10000)
            {
                string polygonstring = &quot;&quot;;
                foreach(Vector2 vertex in vertices)
                {
                    polygonstring += vertex + &quot;, &quot;; 
                }
                Debug.LogError(&quot;Stuck in while loop. Vertices: &quot; + polygonstring);
                break;
            }
        }
        while (!IsPointInPolygon(point));

        return point;
    }

    public Vector2 GetPointInHole(PSLG hole)
    {
        // 10 Get point in hole
        // 20 Is the point in a polygon that the hole is not in
        // 30 if so goto 10 else return
        List&lt;PSLG&gt; polygons = new List&lt;PSLG&gt;();
        for (int i = 0; i &lt; boundaryMarkersForPolygons.Count; i++)
        {
            int startIndex = boundaryMarkersForPolygons[i];
            int endIndex = vertices.Count - 1;
            if (i &lt; boundaryMarkersForPolygons.Count - 1)
                endIndex = boundaryMarkersForPolygons[i + 1] - 1;
            polygons.Add(new PSLG(vertices.GetRange(startIndex, endIndex - startIndex + 1)));
        }
        
        int whileCount = 0;

        Vector2 point;
        bool isPointGood;
        do 
        {
            
            isPointGood = true;
            point = hole.GetPointInPolygon();
            foreach (PSLG polygon in polygons)
            {
                string polygonVertices = &quot;&quot;;
                foreach (Vector2 vertex in polygon.vertices)
                    polygonVertices += vertex + &quot;,&quot;;

                if (polygon.IsPointInPolygon(hole.vertices[0]))
                {
                    // This polygon surrounds the hole, which is OK
                }
                else if (hole.IsPointInPolygon(polygon.vertices[0]))
                {
                    // This polygon is within the hole

                    if (polygon.IsPointInPolygon(point))
                    {
                        // The point is within a polygon that is inside the hole, which is NOT OK
                        isPointGood = false;
                    }
                    else
                    {
                        // But the point was not within this polygon
                    }
                }
                else
                {
                    // This polygon is far away from the hole
                }

            }
            whileCount++;
            if (whileCount &gt; 10000)
            {
                string holestring = &quot;&quot;;
                foreach(Vector2 vertex in hole.vertices)
                {
                    holestring += vertex + &quot;, &quot;;    
                }
                
                Debug.LogError(&quot;Stuck in while loop. Hole vertices: &quot; + holestring);
                break;
            }
        }
        while (!isPointGood);

        return point;
    }
}</code></pre>
  </div><h2>Polygon2D.cs</h2><div>
    <pre><code class='c#'>using UnityEngine;
using System.Collections;

public class Polygon2D {

    public int[] triangles;
    public Vector2[] vertices;

    public Polygon2D(int[] triangle, Vector2[] vertices)
    {
        this.triangles = triangle;
        this.vertices = vertices;
    }
}</code></pre>
  </div><h2>Feedback</h2>
<p>If you found this useful and/or if you have feedback, please let me know <a href='https://twitter.com/mathmos_'>@mathmos_</a>.</p>
	</div>
	<!--<div class="blog_postedby">Posted by: mathmos_</div>
	<div class="blog_timestamp">2013-05-17 00:00:00 +0200</div>-->
</div>
					</div>
				</div>
			</div>
			<div id="footer">Copyright&copy; 2013</div>
		</div>
		<script type="text/javascript">

		  var _gaq = _gaq || [];
		  _gaq.push(['_setAccount', 'UA-6807315-1']);
		  _gaq.push(['_trackPageview']);

		  (function() {
			var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		  })();

		</script>
	</body>
</html>